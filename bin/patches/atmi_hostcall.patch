diff --git a/include/atmi_interop_hsa.h b/include/atmi_interop_hsa.h
index 6bceeea..84524a1 100644
--- a/include/atmi_interop_hsa.h
+++ b/include/atmi_interop_hsa.h
@@ -10,6 +10,10 @@
 #include "hsa.h"
 #include "hsa_ext_amd.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /** \defgroup interop_hsa_functions ATMI-HSA Interop
  *  @{
  */
@@ -121,4 +125,8 @@ atmi_status_t atmi_interop_hsa_get_kernel_info(
     hsa_executable_symbol_info_t info, uint32_t *value);
 /** @} */
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif  // INCLUDE_ATMI_INTEROP_HSA_H_
diff --git a/include/atmi_runtime.h b/include/atmi_runtime.h
index 27424ca..2d28125 100644
--- a/include/atmi_runtime.h
+++ b/include/atmi_runtime.h
@@ -13,6 +13,10 @@
 #include <stdbool.h>
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /** \defgroup kernel Kernel Handles
  * This module includes all kernel-related classes, structs and functions.
  * @{
@@ -22,6 +26,14 @@
  */
 typedef void (*atmi_generic_fp)(void);
 
+typedef unsigned long (*atmi_task_hostcall_handler_t)(void *, uint32_t);
+/**
+ * @brief Register a callback that performs hostcall buffer processing
+ * functions with a task.
+ */
+atmi_status_t atmi_register_task_hostcall_handler(
+    atmi_task_hostcall_handler_t fp);
+
 typedef void (*task_process_init_buffer_t)(void *, int);
 /**
  * @brief Register a callback to init a buffer assoicated with a task
@@ -34,9 +46,6 @@ typedef void (*task_process_fini_buffer_t)(void *, int);
  */
 atmi_status_t atmi_register_task_fini_buffer(task_process_fini_buffer_t fp);
 /** @} */
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /** \defgroup context_functions ATMI Context Setup and Finalize
  *  @{
@@ -499,7 +508,7 @@ atmi_status_t atmi_taskgroup_create(atmi_taskgroup_handle_t *group_handle,
 #else
                                     bool ordered, atmi_place_t place
 #endif
-                                    );
+);
 
 /**
  * @brief Release the task group structure, which could be a group of compute
diff --git a/src/runtime/core/CMakeLists.txt b/src/runtime/core/CMakeLists.txt
index 26200f0..600fc1a 100644
--- a/src/runtime/core/CMakeLists.txt
+++ b/src/runtime/core/CMakeLists.txt
@@ -109,7 +109,6 @@ include_directories(${ROCM_INCLUDE_DIRS})
 include_directories(${CMAKE_CURRENT_SOURCE_DIR})
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../include)
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../../include)
-include_directories(${CMAKE_INSTALL_PREFIX}/include)
 
 ## CPack component info
 set(CPACK_COMPONENT_RUNTIME_DISPLAY_NAME "ATMI Runtime Library")
@@ -123,7 +122,6 @@ target_link_libraries(
   ${ROCM_LIBRARIES}
   -L${ROCM_LIBRARIES_DIR}/../hsa/lib
   -L${ROCM_LIBRARIES_DIR}
-  -L${CMAKE_INSTALL_PREFIX}/lib -lamd_hostcall -Wl,-rpath,${CMAKE_INSTALL_PREFIX}/lib
   -Wl,--enable-new-dtags
   -Wl,-rpath,\$ORIGIN
   -Wl,-rpath,\$ORIGIN/../../hsa/lib
diff --git a/src/runtime/core/atmi.cpp b/src/runtime/core/atmi.cpp
index b350953..b78b579 100644
--- a/src/runtime/core/atmi.cpp
+++ b/src/runtime/core/atmi.cpp
@@ -119,6 +119,10 @@ atmi_status_t atmi_register_task_fini_buffer(task_process_fini_buffer_t fp) {
   return core::Runtime::getInstance().RegisterTaskFiniBuffer(fp);
 }
 
+atmi_status_t atmi_register_task_hostcall_handler(
+    atmi_task_hostcall_handler_t fp) {
+  return core::Runtime::getInstance().RegisterTaskHostcallHandler(fp);
+}
 /*
  * Tasks
  */
diff --git a/src/runtime/core/system.cpp b/src/runtime/core/system.cpp
index 81d6d30..e526467 100644
--- a/src/runtime/core/system.cpp
+++ b/src/runtime/core/system.cpp
@@ -17,7 +17,6 @@
 #include "ATLMachine.h"
 #include "RealTimerClass.h"
 #include "amd_comgr.h"
-#include "amd_hostcall.h"
 #include "atl_internal.h"
 #include "rt.h"
 using core::RealTimer;
@@ -159,8 +158,6 @@ hsa_ext_program_t atl_hsa_program;
 hsa_region_t atl_hsa_primary_region;
 hsa_region_t atl_gpu_kernarg_region;
 hsa_amd_memory_pool_t atl_gpu_kernarg_pool;
-uint32_t atl_hostcall_minpackets;
-bool atl_hostcall_is_required;
 hsa_region_t atl_cpu_kernarg_region;
 hsa_agent_t atl_gpu_agent;
 hsa_profile_t atl_gpu_agent_profile;
@@ -193,6 +190,7 @@ size_t direct_dispatch = 0;
 size_t callback_dispatch = 0;
 
 bool g_atmi_initialized = false;
+bool g_atmi_hostcall_required = false;
 
 struct timespec context_init_time;
 int context_init_time_init = 0;
@@ -269,8 +267,6 @@ atmi_status_t Runtime::Finalize() {
   // TODO(ashwinma): Finalize all processors, queues, signals, kernarg memory
   // regions
   hsa_status_t err;
-  if (atl_hostcall_is_required)
-    atmi_hostcall_terminate();
   finalize_hsa();
   for (int i = 0; i < g_executables.size(); i++) {
     err = hsa_executable_destroy(g_executables[i]);
@@ -397,15 +393,6 @@ static hsa_status_t get_agent_info(hsa_agent_t agent, void *data) {
                                                &new_proc);
       ErrorCheck(Iterate all memory pools, err);
       g_atl_machine.addProcessor(new_proc);
-      uint32_t numCu;
-      err = hsa_agent_get_info(agent, (hsa_agent_info_t)
-          HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT, &numCu);
-      ErrorCheck(Could not get number of cus, err);
-      uint32_t waverPerCu;
-      err = hsa_agent_get_info(agent, (hsa_agent_info_t)
-          HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU, &waverPerCu);
-      ErrorCheck(Could not get number of waves per cu, err);
-      atl_hostcall_minpackets = numCu * waverPerCu;
     } break;
     case HSA_DEVICE_TYPE_DSP: {
       ;
@@ -881,9 +868,6 @@ atmi_status_t atl_init_gpu_context() {
     ErrorCheck(Registering the system for memory faults, err);
 
     init_tasks();
-    // Initiailze hostcall. Note: atl_gpu_agent was initialized by init_hsa
-    atl_hostcall_is_required = false;
-    err=atmi_hostcall_init();
     atlc.g_gpu_initialized = true;
     return ATMI_STATUS_SUCCESS;
 }
@@ -1723,8 +1707,8 @@ hsa_status_t create_kernarg_memory(hsa_executable_t executable,
     register_allocation(reinterpret_cast<void *>(info.addr), (size_t)info.size,
                         place);
     SymbolInfoTable[gpu][std::string(name)] = info;
-    if (strcmp(name,"needs_hostcall_buffer")==0)
-      atl_hostcall_is_required = true;
+    if (strcmp(name, "needs_hostcall_buffer") == 0)
+      g_atmi_hostcall_required = true;
     free(name);
   } else {
     DEBUG_PRINT("Symbol is an indirect function\n");
diff --git a/src/runtime/core/task.cpp b/src/runtime/core/task.cpp
index 9649e4b..0bad5d6 100644
--- a/src/runtime/core/task.cpp
+++ b/src/runtime/core/task.cpp
@@ -27,7 +27,6 @@
 #include "RealTimerClass.h"
 #include "atl_bindthread.h"
 #include "atl_internal.h"
-#include "amd_hostcall.h"
 #include "kernel.h"
 #include "rt.h"
 #include "taskgroup.h"
@@ -51,8 +50,7 @@ std::vector<TaskImpl *> AllTasks;
 std::queue<TaskImpl *> ReadyTaskQueue;
 std::queue<hsa_signal_t> FreeSignalPool;
 
-extern uint32_t atl_hostcall_minpackets;
-extern bool atl_hostcall_is_required;
+extern bool g_atmi_hostcall_required;
 
 std::map<uint64_t, Kernel *> KernelImplMap;
 // std::map<uint64_t, std::vector<std::string> > ModuleMap;
@@ -418,6 +416,23 @@ void TaskImpl::updateMetrics() {
 // function pointers
 task_process_init_buffer_t task_process_init_buffer;
 task_process_fini_buffer_t task_process_fini_buffer;
+atmi_task_hostcall_handler_t task_process_hostcall_handler = NULL;
+
+atmi_status_t Runtime::RegisterTaskHostcallHandler(
+    atmi_task_hostcall_handler_t fp) {
+  atmi_status_t status;
+  if (!task_process_hostcall_handler) {
+    task_process_hostcall_handler = fp;
+    status = ATMI_STATUS_SUCCESS;
+  } else {
+    // Task handler already set. Currently, we support
+    // only single hostcall handlers.
+    DEBUG_PRINT("Task handler already set\n");
+    status = ATMI_STATUS_ERROR;
+  }
+
+  return status;
+}
 
 atmi_status_t Runtime::RegisterTaskInitBuffer(task_process_init_buffer_t fp) {
   // printf("register function pointer \n");
@@ -1069,22 +1084,24 @@ atmi_status_t ComputeTaskImpl::dispatch() {
     // char *pipe_ptr = impl_args->pipe_ptr;
 
     // assign a hostcall buffer for the selected Q
-    if (atl_hostcall_is_required) {
+    {
       KernelImpl *kernel_impl = NULL;
-      if (kernel_) {
-        kernel_impl = kernel_->getKernelImpl(kernel_id_);
-        // printf("Task Id: %lu, kernel name: %s\n", id_,
-        // kernel_impl->kernel_name.c_str());
-        char *kargs = reinterpret_cast<char *>(kernarg_region_);
-        if (type() == ATL_KERNEL_EXECUTION && devtype_ == ATMI_DEVTYPE_GPU &&
-            kernel_impl->platform_type() == AMDGCN) {
-          atmi_implicit_args_t *impl_args =
-            reinterpret_cast<atmi_implicit_args_t *>(
-                kargs +
-                (kernarg_region_size_ - sizeof(atmi_implicit_args_t)));
+      if (g_atmi_hostcall_required && task_process_hostcall_handler) {
+        if (kernel_) {
+          kernel_impl = kernel_->getKernelImpl(kernel_id_);
+          // printf("Task Id: %lu, kernel name: %s\n", id_,
+          // kernel_impl->kernel_name.c_str());
+          char *kargs = reinterpret_cast<char *>(kernarg_region_);
+          if (type() == ATL_KERNEL_EXECUTION && devtype_ == ATMI_DEVTYPE_GPU &&
+              kernel_impl->platform_type() == AMDGCN) {
+            atmi_implicit_args_t *impl_args =
+                reinterpret_cast<atmi_implicit_args_t *>(
+                    kargs +
+                    (kernarg_region_size_ - sizeof(atmi_implicit_args_t)));
 
-          impl_args->hostcall_ptr = atmi_hostcall_assign_buffer(atl_hostcall_minpackets,
-              this_Q, proc_id);
+            impl_args->hostcall_ptr =
+                (*task_process_hostcall_handler)(this_Q, proc_id);
+          }
         }
       }
     }
diff --git a/src/runtime/include/rt.h b/src/runtime/include/rt.h
index e0fadc5..347ee68 100644
--- a/src/runtime/include/rt.h
+++ b/src/runtime/include/rt.h
@@ -96,6 +96,7 @@ class Runtime {
   // print buffers/pipes
   atmi_status_t RegisterTaskInitBuffer(task_process_init_buffer_t);
   atmi_status_t RegisterTaskFiniBuffer(task_process_fini_buffer_t);
+  atmi_status_t RegisterTaskHostcallHandler(atmi_task_hostcall_handler_t fp);
   // tasks
   atmi_task_handle_t CreateTaskTemplate(atmi_kernel_t);
   atmi_task_handle_t ActivateTaskTemplate(atmi_task_handle_t, atmi_lparm_t *,
