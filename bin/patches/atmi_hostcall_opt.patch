From 6f2cde5120fe645f9568d9172f2e1e26254eccf4 Mon Sep 17 00:00:00 2001
From: Ashwin Aji <ashwin.aji@amd.com>
Date: Tue, 28 Jan 2020 15:48:41 -0800
Subject: [PATCH] ATMI Hostcall Optimization

* [AOMP] Adding hostcall callback implementation. Checks for
needs_hostcall_buffer symbol. There is no dependency on libamd_hostcall.
Created clear interfaces for hostcall implementations to
register its handlers with ATMI, which will then be invoked
during task launch.
---
 include/atmi_interop_hsa.h  |  8 +++++++
 include/atmi_kl.h           |  1 +
 include/atmi_runtime.h      | 17 +++++++++++----
 src/runtime/core/atmi.cpp   |  4 ++++
 src/runtime/core/system.cpp |  3 +++
 src/runtime/core/task.cpp   | 42 +++++++++++++++++++++++++++++++++++++
 src/runtime/include/rt.h    |  1 +
 7 files changed, 72 insertions(+), 4 deletions(-)

diff --git a/include/atmi_interop_hsa.h b/include/atmi_interop_hsa.h
index 6bceeea..84524a1 100644
--- a/include/atmi_interop_hsa.h
+++ b/include/atmi_interop_hsa.h
@@ -10,6 +10,10 @@
 #include "hsa.h"
 #include "hsa_ext_amd.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /** \defgroup interop_hsa_functions ATMI-HSA Interop
  *  @{
  */
@@ -121,4 +125,8 @@ atmi_status_t atmi_interop_hsa_get_kernel_info(
     hsa_executable_symbol_info_t info, uint32_t *value);
 /** @} */
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif  // INCLUDE_ATMI_INTEROP_HSA_H_
diff --git a/include/atmi_kl.h b/include/atmi_kl.h
index e6493d5..abe151c 100644
--- a/include/atmi_kl.h
+++ b/include/atmi_kl.h
@@ -20,6 +20,7 @@ typedef struct atmi_implicit_args_s {
   unsigned long offset_x;
   unsigned long offset_y;
   unsigned long offset_z;
+  unsigned long hostcall_ptr;
   unsigned long pipe_ptr;
   char num_gpu_queues;
   unsigned long gpu_queue_ptr;
diff --git a/include/atmi_runtime.h b/include/atmi_runtime.h
index 27424ca..2d28125 100644
--- a/include/atmi_runtime.h
+++ b/include/atmi_runtime.h
@@ -13,6 +13,10 @@
 #include <stdbool.h>
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /** \defgroup kernel Kernel Handles
  * This module includes all kernel-related classes, structs and functions.
  * @{
@@ -22,6 +26,14 @@
  */
 typedef void (*atmi_generic_fp)(void);
 
+typedef unsigned long (*atmi_task_hostcall_handler_t)(void *, uint32_t);
+/**
+ * @brief Register a callback that performs hostcall buffer processing
+ * functions with a task.
+ */
+atmi_status_t atmi_register_task_hostcall_handler(
+    atmi_task_hostcall_handler_t fp);
+
 typedef void (*task_process_init_buffer_t)(void *, int);
 /**
  * @brief Register a callback to init a buffer assoicated with a task
@@ -34,9 +46,6 @@ typedef void (*task_process_fini_buffer_t)(void *, int);
  */
 atmi_status_t atmi_register_task_fini_buffer(task_process_fini_buffer_t fp);
 /** @} */
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /** \defgroup context_functions ATMI Context Setup and Finalize
  *  @{
@@ -499,7 +508,7 @@ atmi_status_t atmi_taskgroup_create(atmi_taskgroup_handle_t *group_handle,
 #else
                                     bool ordered, atmi_place_t place
 #endif
-                                    );
+);
 
 /**
  * @brief Release the task group structure, which could be a group of compute
diff --git a/src/runtime/core/atmi.cpp b/src/runtime/core/atmi.cpp
index b350953..b78b579 100644
--- a/src/runtime/core/atmi.cpp
+++ b/src/runtime/core/atmi.cpp
@@ -119,6 +119,10 @@ atmi_status_t atmi_register_task_fini_buffer(task_process_fini_buffer_t fp) {
   return core::Runtime::getInstance().RegisterTaskFiniBuffer(fp);
 }
 
+atmi_status_t atmi_register_task_hostcall_handler(
+    atmi_task_hostcall_handler_t fp) {
+  return core::Runtime::getInstance().RegisterTaskHostcallHandler(fp);
+}
 /*
  * Tasks
  */
diff --git a/src/runtime/core/system.cpp b/src/runtime/core/system.cpp
index de73749..e526467 100644
--- a/src/runtime/core/system.cpp
+++ b/src/runtime/core/system.cpp
@@ -190,6 +190,7 @@ size_t direct_dispatch = 0;
 size_t callback_dispatch = 0;
 
 bool g_atmi_initialized = false;
+bool g_atmi_hostcall_required = false;
 
 struct timespec context_init_time;
 int context_init_time_init = 0;
@@ -1706,6 +1707,8 @@ hsa_status_t create_kernarg_memory(hsa_executable_t executable,
     register_allocation(reinterpret_cast<void *>(info.addr), (size_t)info.size,
                         place);
     SymbolInfoTable[gpu][std::string(name)] = info;
+    if (strcmp(name, "needs_hostcall_buffer") == 0)
+      g_atmi_hostcall_required = true;
     free(name);
   } else {
     DEBUG_PRINT("Symbol is an indirect function\n");
diff --git a/src/runtime/core/task.cpp b/src/runtime/core/task.cpp
index 18542eb..0bad5d6 100644
--- a/src/runtime/core/task.cpp
+++ b/src/runtime/core/task.cpp
@@ -50,6 +50,8 @@ std::vector<TaskImpl *> AllTasks;
 std::queue<TaskImpl *> ReadyTaskQueue;
 std::queue<hsa_signal_t> FreeSignalPool;
 
+extern bool g_atmi_hostcall_required;
+
 std::map<uint64_t, Kernel *> KernelImplMap;
 // std::map<uint64_t, std::vector<std::string> > ModuleMap;
 bool setCallbackToggle = false;
@@ -414,6 +416,23 @@ void TaskImpl::updateMetrics() {
 // function pointers
 task_process_init_buffer_t task_process_init_buffer;
 task_process_fini_buffer_t task_process_fini_buffer;
+atmi_task_hostcall_handler_t task_process_hostcall_handler = NULL;
+
+atmi_status_t Runtime::RegisterTaskHostcallHandler(
+    atmi_task_hostcall_handler_t fp) {
+  atmi_status_t status;
+  if (!task_process_hostcall_handler) {
+    task_process_hostcall_handler = fp;
+    status = ATMI_STATUS_SUCCESS;
+  } else {
+    // Task handler already set. Currently, we support
+    // only single hostcall handlers.
+    DEBUG_PRINT("Task handler already set\n");
+    status = ATMI_STATUS_ERROR;
+  }
+
+  return status;
+}
 
 atmi_status_t Runtime::RegisterTaskInitBuffer(task_process_init_buffer_t fp) {
   // printf("register function pointer \n");
@@ -1064,6 +1083,29 @@ atmi_status_t ComputeTaskImpl::dispatch() {
     impl_args->offset_z = 0;
     // char *pipe_ptr = impl_args->pipe_ptr;
 
+    // assign a hostcall buffer for the selected Q
+    {
+      KernelImpl *kernel_impl = NULL;
+      if (g_atmi_hostcall_required && task_process_hostcall_handler) {
+        if (kernel_) {
+          kernel_impl = kernel_->getKernelImpl(kernel_id_);
+          // printf("Task Id: %lu, kernel name: %s\n", id_,
+          // kernel_impl->kernel_name.c_str());
+          char *kargs = reinterpret_cast<char *>(kernarg_region_);
+          if (type() == ATL_KERNEL_EXECUTION && devtype_ == ATMI_DEVTYPE_GPU &&
+              kernel_impl->platform_type() == AMDGCN) {
+            atmi_implicit_args_t *impl_args =
+                reinterpret_cast<atmi_implicit_args_t *>(
+                    kargs +
+                    (kernarg_region_size_ - sizeof(atmi_implicit_args_t)));
+
+            impl_args->hostcall_ptr =
+                (*task_process_hostcall_handler)(this_Q, proc_id);
+          }
+        }
+      }
+    }
+
     // initialize printf buffer
     {
       KernelImpl *kernel_impl = NULL;
diff --git a/src/runtime/include/rt.h b/src/runtime/include/rt.h
index e0fadc5..347ee68 100644
--- a/src/runtime/include/rt.h
+++ b/src/runtime/include/rt.h
@@ -96,6 +96,7 @@ class Runtime {
   // print buffers/pipes
   atmi_status_t RegisterTaskInitBuffer(task_process_init_buffer_t);
   atmi_status_t RegisterTaskFiniBuffer(task_process_fini_buffer_t);
+  atmi_status_t RegisterTaskHostcallHandler(atmi_task_hostcall_handler_t fp);
   // tasks
   atmi_task_handle_t CreateTaskTemplate(atmi_kernel_t);
   atmi_task_handle_t ActivateTaskTemplate(atmi_task_handle_t, atmi_lparm_t *,
