commit bde6a7143b499939834bd9930ab25e0fdb3ea0f2
Author: Ethan Stewart <ethan.stewart@amd.com>
Date:   Sun Feb 23 13:16:25 2020 -0600

    Revert "Changes required due to upstream llvm changes"
    
    This reverts commit 7ac2e34f13eb3fc7bdf5211a487726084eb4e906.

diff --git a/lib/comgr/src/comgr-objdump.cpp b/lib/comgr/src/comgr-objdump.cpp
index a28ebe1..5a2f6e5 100644
--- a/lib/comgr/src/comgr-objdump.cpp
+++ b/lib/comgr/src/comgr-objdump.cpp
@@ -256,6 +256,8 @@ cl::opt<unsigned long long> StopAddress("stop-address",
                                         cl::init(UINT64_MAX));
 static StringRef ToolName = "DisassemblerAction";
 
+typedef std::vector<std::tuple<uint64_t, StringRef, uint8_t>> SectionSymbolsTy;
+
 namespace {
 typedef std::function<bool(llvm::object::SectionRef const &)> FilterPredicate;
 
@@ -1343,8 +1345,8 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
     std::vector<uint64_t> TextMappingSymsAddr;
     if (isArmElf(Obj)) {
       for (const auto &Symb : Symbols) {
-        uint64_t Address = Symb.Addr;
-        StringRef Name = Symb.Name;
+        uint64_t Address = std::get<0>(Symb);
+        StringRef Name = std::get<1>(Symb);
         if (Name.startswith("$d"))
           DataMappingSymsAddr.push_back(Address - SectionAddr);
         if (Name.startswith("$x"))
@@ -1399,11 +1401,11 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
     }
 
     // If the section has no symbol at the start, just insert a dummy one.
-    if (Symbols.empty() || Symbols[0].Addr != 0) {
+    if (Symbols.empty() || std::get<0>(Symbols[0]) != 0) {
       Symbols.insert(
           Symbols.begin(),
-          SymbolInfoTy(SectionAddr, name,
-                       Section.isText() ? ELF::STT_FUNC : ELF::STT_OBJECT));
+          std::make_tuple(SectionAddr, name,
+                          Section.isText() ? ELF::STT_FUNC : ELF::STT_OBJECT));
     }
 
     SmallString<40> Comments;
@@ -1426,12 +1428,12 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
     std::vector<RelocationRef>::const_iterator rel_end = Rels.end();
     // Disassemble symbol by symbol.
     for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
-      uint64_t Start = Symbols[si].Addr - SectionAddr;
+      uint64_t Start = std::get<0>(Symbols[si]) - SectionAddr;
       // The end is either the section end or the beginning of the next
       // symbol.
       uint64_t End = (si == se - 1)
                          ? SectSize
-                         : Symbols[si + 1].Addr - SectionAddr;
+                         : std::get<0>(Symbols[si + 1]) - SectionAddr;
       // Don't try to disassemble beyond the end of section contents.
       if (End > SectSize)
         End = SectSize;
@@ -1453,12 +1455,12 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
       if (Obj->isELF() && Obj->getArch() == Triple::amdgcn) {
         // make size 4 bytes folded
         End = Start + ((End - Start) & ~0x3ull);
-        if (Symbols[si].Type == ELF::STT_AMDGPU_HSA_KERNEL) {
+        if (std::get<2>(Symbols[si]) == ELF::STT_AMDGPU_HSA_KERNEL) {
           // skip amd_kernel_code_t at the begining of kernel symbol (256 bytes)
           Start += 256;
         }
         if (si == se - 1 ||
-            Symbols[si + 1].Type == ELF::STT_AMDGPU_HSA_KERNEL) {
+            std::get<2>(Symbols[si + 1]) == ELF::STT_AMDGPU_HSA_KERNEL) {
           // cut trailing zeroes at the end of kernel
           // cut up to 256 bytes
           const uint64_t EndAlign = 256;
@@ -1470,7 +1472,7 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
       }
 
       // COMGR TBD: Get rid of ".text:"??
-      OutS << '\n' << Symbols[si].Name << ":\n";
+      OutS << '\n' << std::get<1>(Symbols[si]) << ":\n";
 
       for (Index = Start; Index < End; Index += Size) {
         MCInst Inst;
@@ -1485,7 +1487,7 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
         // same section. We rely on the markers introduced to
         // understand what we need to dump. If the data marker is within a
         // function, it is denoted as a word/short etc
-        if (isArmElf(Obj) && Symbols[si].Type != ELF::STT_OBJECT &&
+        if (isArmElf(Obj) && std::get<2>(Symbols[si]) != ELF::STT_OBJECT &&
             !DisassembleAll) {
           uint64_t Stride = 0;
 
@@ -1549,7 +1551,7 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
         // disassembling text (applicable all architectures),
         // we are in a situation where we must print the data and not
         // disassemble it.
-        if (Obj->isELF() && Symbols[si].Type == ELF::STT_OBJECT &&
+        if (Obj->isELF() && std::get<2>(Symbols[si]) == ELF::STT_OBJECT &&
             !DisassembleAll && Section.isText()) {
           // print out data up to 8 bytes at a time in hex and ascii
           uint8_t AsciiData[9] = {'\0'};
@@ -1638,13 +1640,13 @@ void llvm::DisassemHelper::DisassembleObject(const ObjectFile *Obj,
                   TargetSectionSymbols->begin(), TargetSectionSymbols->end(),
                   Target,
                   [](uint64_t LHS,
-                     const SymbolInfoTy &RHS) {
-                    return LHS < RHS.Addr;
+                     const std::tuple<uint64_t, StringRef, uint8_t> &RHS) {
+                    return LHS < std::get<0>(RHS);
                   });
               if (TargetSym != TargetSectionSymbols->begin()) {
                 --TargetSym;
-                uint64_t TargetAddress = TargetSym->Addr;
-                StringRef TargetName = TargetSym->Name;
+                uint64_t TargetAddress = std::get<0>(*TargetSym);
+                StringRef TargetName = std::get<1>(*TargetSym);
                 OutS << " <" << TargetName;
                 uint64_t Disp = Target - TargetAddress;
                 if (Disp)
