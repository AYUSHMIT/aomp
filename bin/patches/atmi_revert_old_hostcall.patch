From d5229e9503c557a407bba2e2ea95061e6f3fdb07 Mon Sep 17 00:00:00 2001
From: Ashwin Aji <ashwin.aji@amd.com>
Date: Tue, 28 Jan 2020 14:52:46 -0800
Subject: [PATCH] Revert "Adding hostcall implementation to ATMI. Check for"

This reverts commit 4b968f77aa6fd5e10b5ba6e789748ac5fa11511f.
---
 include/atmi_kl.h               |  1 -
 src/runtime/core/CMakeLists.txt |  2 --
 src/runtime/core/system.cpp     | 19 -------------------
 src/runtime/core/task.cpp       | 25 -------------------------
 4 files changed, 47 deletions(-)

diff --git a/include/atmi_kl.h b/include/atmi_kl.h
index abe151c..e6493d5 100644
--- a/include/atmi_kl.h
+++ b/include/atmi_kl.h
@@ -20,7 +20,6 @@ typedef struct atmi_implicit_args_s {
   unsigned long offset_x;
   unsigned long offset_y;
   unsigned long offset_z;
-  unsigned long hostcall_ptr;
   unsigned long pipe_ptr;
   char num_gpu_queues;
   unsigned long gpu_queue_ptr;
diff --git a/src/runtime/core/CMakeLists.txt b/src/runtime/core/CMakeLists.txt
index 26200f0..600fc1a 100644
--- a/src/runtime/core/CMakeLists.txt
+++ b/src/runtime/core/CMakeLists.txt
@@ -109,7 +109,6 @@ include_directories(${ROCM_INCLUDE_DIRS})
 include_directories(${CMAKE_CURRENT_SOURCE_DIR})
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../include)
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../../include)
-include_directories(${CMAKE_INSTALL_PREFIX}/include)
 
 ## CPack component info
 set(CPACK_COMPONENT_RUNTIME_DISPLAY_NAME "ATMI Runtime Library")
@@ -123,7 +122,6 @@ target_link_libraries(
   ${ROCM_LIBRARIES}
   -L${ROCM_LIBRARIES_DIR}/../hsa/lib
   -L${ROCM_LIBRARIES_DIR}
-  -L${CMAKE_INSTALL_PREFIX}/lib -lamd_hostcall -Wl,-rpath,${CMAKE_INSTALL_PREFIX}/lib
   -Wl,--enable-new-dtags
   -Wl,-rpath,\$ORIGIN
   -Wl,-rpath,\$ORIGIN/../../hsa/lib
diff --git a/src/runtime/core/system.cpp b/src/runtime/core/system.cpp
index 81d6d30..de73749 100644
--- a/src/runtime/core/system.cpp
+++ b/src/runtime/core/system.cpp
@@ -17,7 +17,6 @@
 #include "ATLMachine.h"
 #include "RealTimerClass.h"
 #include "amd_comgr.h"
-#include "amd_hostcall.h"
 #include "atl_internal.h"
 #include "rt.h"
 using core::RealTimer;
@@ -159,8 +158,6 @@ hsa_ext_program_t atl_hsa_program;
 hsa_region_t atl_hsa_primary_region;
 hsa_region_t atl_gpu_kernarg_region;
 hsa_amd_memory_pool_t atl_gpu_kernarg_pool;
-uint32_t atl_hostcall_minpackets;
-bool atl_hostcall_is_required;
 hsa_region_t atl_cpu_kernarg_region;
 hsa_agent_t atl_gpu_agent;
 hsa_profile_t atl_gpu_agent_profile;
@@ -269,8 +266,6 @@ atmi_status_t Runtime::Finalize() {
   // TODO(ashwinma): Finalize all processors, queues, signals, kernarg memory
   // regions
   hsa_status_t err;
-  if (atl_hostcall_is_required)
-    atmi_hostcall_terminate();
   finalize_hsa();
   for (int i = 0; i < g_executables.size(); i++) {
     err = hsa_executable_destroy(g_executables[i]);
@@ -397,15 +392,6 @@ static hsa_status_t get_agent_info(hsa_agent_t agent, void *data) {
                                                &new_proc);
       ErrorCheck(Iterate all memory pools, err);
       g_atl_machine.addProcessor(new_proc);
-      uint32_t numCu;
-      err = hsa_agent_get_info(agent, (hsa_agent_info_t)
-          HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT, &numCu);
-      ErrorCheck(Could not get number of cus, err);
-      uint32_t waverPerCu;
-      err = hsa_agent_get_info(agent, (hsa_agent_info_t)
-          HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU, &waverPerCu);
-      ErrorCheck(Could not get number of waves per cu, err);
-      atl_hostcall_minpackets = numCu * waverPerCu;
     } break;
     case HSA_DEVICE_TYPE_DSP: {
       ;
@@ -881,9 +867,6 @@ atmi_status_t atl_init_gpu_context() {
     ErrorCheck(Registering the system for memory faults, err);
 
     init_tasks();
-    // Initiailze hostcall. Note: atl_gpu_agent was initialized by init_hsa
-    atl_hostcall_is_required = false;
-    err=atmi_hostcall_init();
     atlc.g_gpu_initialized = true;
     return ATMI_STATUS_SUCCESS;
 }
@@ -1723,8 +1706,6 @@ hsa_status_t create_kernarg_memory(hsa_executable_t executable,
     register_allocation(reinterpret_cast<void *>(info.addr), (size_t)info.size,
                         place);
     SymbolInfoTable[gpu][std::string(name)] = info;
-    if (strcmp(name,"needs_hostcall_buffer")==0)
-      atl_hostcall_is_required = true;
     free(name);
   } else {
     DEBUG_PRINT("Symbol is an indirect function\n");
diff --git a/src/runtime/core/task.cpp b/src/runtime/core/task.cpp
index 9649e4b..18542eb 100644
--- a/src/runtime/core/task.cpp
+++ b/src/runtime/core/task.cpp
@@ -27,7 +27,6 @@
 #include "RealTimerClass.h"
 #include "atl_bindthread.h"
 #include "atl_internal.h"
-#include "amd_hostcall.h"
 #include "kernel.h"
 #include "rt.h"
 #include "taskgroup.h"
@@ -51,9 +50,6 @@ std::vector<TaskImpl *> AllTasks;
 std::queue<TaskImpl *> ReadyTaskQueue;
 std::queue<hsa_signal_t> FreeSignalPool;
 
-extern uint32_t atl_hostcall_minpackets;
-extern bool atl_hostcall_is_required;
-
 std::map<uint64_t, Kernel *> KernelImplMap;
 // std::map<uint64_t, std::vector<std::string> > ModuleMap;
 bool setCallbackToggle = false;
@@ -1068,27 +1064,6 @@ atmi_status_t ComputeTaskImpl::dispatch() {
     impl_args->offset_z = 0;
     // char *pipe_ptr = impl_args->pipe_ptr;
 
-    // assign a hostcall buffer for the selected Q
-    if (atl_hostcall_is_required) {
-      KernelImpl *kernel_impl = NULL;
-      if (kernel_) {
-        kernel_impl = kernel_->getKernelImpl(kernel_id_);
-        // printf("Task Id: %lu, kernel name: %s\n", id_,
-        // kernel_impl->kernel_name.c_str());
-        char *kargs = reinterpret_cast<char *>(kernarg_region_);
-        if (type() == ATL_KERNEL_EXECUTION && devtype_ == ATMI_DEVTYPE_GPU &&
-            kernel_impl->platform_type() == AMDGCN) {
-          atmi_implicit_args_t *impl_args =
-            reinterpret_cast<atmi_implicit_args_t *>(
-                kargs +
-                (kernarg_region_size_ - sizeof(atmi_implicit_args_t)));
-
-          impl_args->hostcall_ptr = atmi_hostcall_assign_buffer(atl_hostcall_minpackets,
-              this_Q, proc_id);
-        }
-      }
-    }
-
     // initialize printf buffer
     {
       KernelImpl *kernel_impl = NULL;
