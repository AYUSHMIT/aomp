
This xteamr smoke test executes a simulated reductions directly using the 
DeviceRTL xteam helper functions and compares to the existing OpenMP reduction.

The simulated functions in the ReductionsTestClass show what clang codegen
should generate when it encounters an omp target pragma with one or more sum reductions.
i.e.

#pragma omp target teams distribute parallel for reduction(+:redvar)

The reduction variable redvar can be double, float, int, uint, long, ulong, float _Complex, or double _Complex. 

or min or max reductions like these

#pragma omp target teams distribute parallel for reduction(min:redvar)
#pragma omp target teams distribute parallel for reduction(max:redvar)

For min and max, the reduction variable redvar can be double, float, int, uint, long, or ulong
because complex numbers do not suport comparison operators.

These are the interfaces to the helper functions that clang codegen is expected to generate
function calls for:

///  __kmpc_xteamr_<dtype>_<waves>xWSZ: Helper functions for Cross Team
///  reductions
///    <waves> number of warps/waves in thread block
///    WSZ     warp size, so <waves> x WSZ is the team size in threads
///                       example: 16x64 is a teamsize = 1024 threads
///    arg1: the thread local reduction value.
///    arg2: pointer to where result is written.
///    arg3: global array of team values for this reduction instance.
///    arg4: atomic counter of completed teams for this reduction instance.
///    arg5: function pointer to reduction type function (sum,min,max)
///    arg6: function pointer to reduction type function on LDS memory
///    arg7: Initializing value for the reduction type
void __kmpc_xteamr_d_16x64(double v, double *r_ptr, double *tvals,
                           uint32_t *td_ptr, void (*_rf)(double *, double),
                           void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                           double iv);
void __kmpc_xteamr_f_16x64(float v, float *r_ptr, float *tvals,
                           uint32_t *td_ptr, void (*_rf)(float *, float),
                           void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                           float iv);
void __kmpc_xteamr_i_16x64(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                           void (*_rf)(int *, int),
                           void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                           int iv);
void __kmpc_xteamr_ui_16x64(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                            void (*_rf_lds)(_RF_LDS uint32_t *,
                                            _RF_LDS uint32_t *),
                            uint32_t iv);
void __kmpc_xteamr_l_16x64(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                           void (*_rf)(long *, long),
                           void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                           long iv);
void __kmpc_xteamr_ul_16x64(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                            void (*_rf_lds)(_RF_LDS uint64_t *,
                                            _RF_LDS uint64_t *),
                            uint64_t iv);
void __kmpc_xteamr_d_8x64(double v, double *r_ptr, double *tvals,
                          uint32_t *td_ptr, void (*_rf)(double *, double),
                          void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                          double iv);
void __kmpc_xteamr_f_8x64(float v, float *r_ptr, float *tvals, uint32_t *td_ptr,
                          void (*_rf)(float *, float),
                          void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                          float iv);
void __kmpc_xteamr_i_8x64(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                          void (*_rf)(int *, int),
                          void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                          int iv);
void __kmpc_xteamr_ui_8x64(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                           void (*_rf_lds)(_RF_LDS uint32_t *,
                                           _RF_LDS uint32_t *),
                           uint32_t iv);
void __kmpc_xteamr_l_8x64(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                          void (*_rf)(long *, long),
                          void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                          long iv);
void __kmpc_xteamr_ul_8x64(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                           void (*_rf_lds)(_RF_LDS uint64_t *,
                                           _RF_LDS uint64_t *),
                           uint64_t iv);
void __kmpc_xteamr_d_4x64(double v, double *r_ptr, double *tvals,
                          uint32_t *td_ptr, void (*_rf)(double *, double),
                          void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                          double iv);
void __kmpc_xteamr_f_4x64(float v, float *r_ptr, float *tvals, uint32_t *td_ptr,
                          void (*_rf)(float *, float),
                          void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                          float iv);
void __kmpc_xteamr_i_4x64(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                          void (*_rf)(int *, int),
                          void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                          int iv);
void __kmpc_xteamr_ui_4x64(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                           void (*_rf_lds)(_RF_LDS uint32_t *,
                                           _RF_LDS uint32_t *),
                           uint32_t iv);
void __kmpc_xteamr_l_4x64(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                          void (*_rf)(long *, long),
                          void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                          long iv);
void __kmpc_xteamr_ul_4x64(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                           void (*_rf_lds)(_RF_LDS uint64_t *,
                                           _RF_LDS uint64_t *),
                           uint64_t iv);
void __kmpc_xteamr_d_32x32(double v, double *r_ptr, double *tvals,
                           uint32_t *td_ptr, void (*_rf)(double *, double),
                           void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                           double iv);

void __kmpc_xteamr_f_32x32(float v, float *r_ptr, float *tvals,
                           uint32_t *td_ptr, void (*_rf)(float *, float),
                           void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                           float iv);

void __kmpc_xteamr_i_32x32(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                           void (*_rf)(int *, int),
                           void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                           int iv);

void __kmpc_xteamr_ui_32x32(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                            void (*_rf_lds)(_RF_LDS uint32_t *,
                                            _RF_LDS uint32_t *),
                            uint32_t iv);
void __kmpc_xteamr_l_32x32(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                           void (*_rf)(long *, long),
                           void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                           long iv);
void __kmpc_xteamr_ul_32x32(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                            void (*_rf_lds)(_RF_LDS uint64_t *,
                                            _RF_LDS uint64_t *),
                            uint64_t iv);
void __kmpc_xteamr_d_16x32(double v, double *r_ptr, double *tvals,
                           uint32_t *td_ptr, void (*_rf)(double *, double),
                           void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                           double iv);

void __kmpc_xteamr_f_16x32(float v, float *r_ptr, float *tvals,
                           uint32_t *td_ptr, void (*_rf)(float *, float),
                           void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                           float iv);

void __kmpc_xteamr_i_16x32(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                           void (*_rf)(int *, int),
                           void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                           int iv);
void __kmpc_xteamr_ui_16x32(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                            void (*_rf_lds)(_RF_LDS uint32_t *,
                                            _RF_LDS uint32_t *),
                            uint32_t iv);
void __kmpc_xteamr_l_16x32(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                           void (*_rf)(long *, long),
                           void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                           long iv);
void __kmpc_xteamr_ul_16x32(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                            uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                            void (*_rf_lds)(_RF_LDS uint64_t *,
                                            _RF_LDS uint64_t *),
                            uint64_t iv);
void __kmpc_xteamr_d_8x32(double v, double *r_ptr, double *tvals,
                          uint32_t *td_ptr, void (*_rf)(double *, double),
                          void (*_rf_lds)(_RF_LDS double *, _RF_LDS double *),
                          double iv);
void __kmpc_xteamr_f_8x32(float v, float *r_ptr, float *tvals, uint32_t *td_ptr,
                          void (*_rf)(float *, float),
                          void (*_rf_lds)(_RF_LDS float *, _RF_LDS float *),
                          float iv);
void __kmpc_xteamr_i_8x32(int v, int *r_ptr, int *tvals, uint32_t *td_ptr,
                          void (*_rf)(int *, int),
                          void (*_rf_lds)(_RF_LDS int *, _RF_LDS int *),
                          int iv);
void __kmpc_xteamr_ui_8x32(uint32_t v, uint32_t *r_ptr, uint32_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint32_t *, uint32_t),
                           void (*_rf_lds)(_RF_LDS uint32_t *,
                                           _RF_LDS uint32_t *),
                           uint32_t iv);
void __kmpc_xteamr_l_8x32(long v, long *r_ptr, long *tvals, uint32_t *td_ptr,
                          void (*_rf)(long *, long),
                          void (*_rf_lds)(_RF_LDS long *, _RF_LDS long *),
                          long iv);
void __kmpc_xteamr_ul_8x32(uint64_t v, uint64_t *r_ptr, uint64_t *tvals,
                           uint32_t *td_ptr, void (*_rf)(uint64_t *, uint64_t),
                           void (*_rf_lds)(_RF_LDS uint64_t *,
                                           _RF_LDS uint64_t *),
                           uint64_t iv);
The definitions of the above functions can be found in the new llvm DeviceRTL here: 
llvm-project/openmp/libomptarget/DeviceRTL/include/Interface.h

The goal of this smoke test is to ensure that the DeviceRTL helper functions in Xteamr.cpp
are correct and performant. This smoke test (xteamr) will fail (return a nonzero return code) 
if either the openmp reduction or the simulated reduction get the wrong answer.  

TODO: 
  - Add a loop to test different vector lengths. 
  - Add timings for host version of reduction. 
  - Determine cutoff points (vector lengths) where it would be better to use host reduction
  - Test for overflow.
  - For complex functions use conjugates to test correctness of complex math
      Make c = a*b 
      set a[i] = (1 + 1i) and b[i] = (1 - 1i) 
      then each c[i] should be (2 + 0i) and the sum reduction 
      of vector c should be (ARRAY_SIZE*2 + 0i). 


