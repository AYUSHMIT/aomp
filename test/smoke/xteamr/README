
This xteamr test executes simulated reductions using the DeviceRTL xteam helper 
functions and compares to the existing OpenMP reduction.

First apply DeviceRTL-xteamr.patch toyour llvm-project repo, then rebuild DeviceRTL.
Then edit compile_run to indicate your trunk installation.  Then execute compile_run.
. compile_run

One example ouput from our v100 is in sm_70_output.txt

The simulated functions sim_dot, sim_max, and sim_min show what clang would
generate when it encounters an omp target pragma with one or more sum reductions.
See example below. 

The clang CodeGen changes are not yet complete. 

The interfaces to the helper functions that clang codegen is expected to generate
are in DeviceDeclares.h. This is a subset of the DeviceRTL interfaces found in 

  llvm-project/openmp/libomptarget/DeviceRTL/include/Interface.h

This is the documentation found in Interface.h for these functions.

///  Helper functions for high performance cross team reductions.
///
///    Name decoder:  __kmpc_xteamr_<dtype>_<waves>x<warpsize>
///       <waves> number of warps/waves in team
///       <warpsize> 32 or 64
///       example: __kmpc_xteam_f_16x64 is the helper function for data
///                type float with fixed teamsize of 1024 threads.
///    There are 48(6 X 8) helper functions.
///    6 configurations of teamsize are currently created.
///    The most performant configs use max teamsize 1024: 16x64 and 32x32.
///    Currently the Other confis are 8x64, 4x64, 16x32, and 8x32.
///    8 data types available: double, float, int, uint, long, ulong,
///    double  _Complex, and float _complex
///    All xteam helper functions have these 7 args:
///      arg1: the thread local reduction value
///      arg2: pointer to where result is written
///      arg3: global array of team values for this reduction instance
///      arg4: atomic counter of completed teams for this reduction instance
///      arg5: void function pointer of  pair reduction function,
///            (e.g. sum(&a,b),min(&a,b),max(&a,b)
///      arg6: equivalent (to arg5) void function pointer of pair reduction
///            function on LDS memory, (e.g. sum(&a,&b),min(&a,&b),max(&a,&b)
///      arg7: Initializing value for the reduction type


The definitions of the above functions can be found in the new llvm DeviceRTL here: 
  llvm-project/openmp/libomptarget/DeviceRTL/src/Xteamr.cpp

The builtin simple pair reducing functions can be found here:
  llvm-project/openmp/libomptarget/DeviceRTL/src/Rfuns.cpp

EXAMPLE: Given this code:

      double sum = 0.0;
      #pragma omp target teams distribute parallel for map(tofrom: sum) reduction(+:sum)
      for (int i = 0; i < array_size; i++)
        sum += a[i] * b[i];

Clang should generate code equivalent to this. 

      devid = 0 ; // or default or whatever is on target construct
      team_procs = ompx_get_team_procs(devid);
      team_vals0  = (double *) omp_target_alloc(sizeof(double) * team_procs, devid);
      teams_done_ptr0 = (uint32_t *) omp_target_alloc(sizeof(uint32_t),devid);
      #pragma omp target teams distribute parallel for \
         num_teams(team_procs) num_threads(1024) \
         map(tofrom:sum) is_device_ptr(team_vals0,teams_done_ptr0)
      for (unsigned int k=0; k<(team_procs*1024) ; k++) {
        T val0 = 0.0;
        for (unsigned int i = k; i < array_size; i += team_procs*1023) {
          val0 += a[i] * b[i];
        }
        __kmpc_xteamr_d_16x64(val0, &sum, team_vals0, teams_done_ptr0, 
             __kmpc_rfun_sum_d, __kmpc_rfun_sum_lds_d,0.0);
      }


The goal of this smoke test is to ensure that the DeviceRTL helper functions in Xteamr.cpp
are correct and performant. This test (xteamr) will fail (return a nonzero return code) 
if either the openmp reduction or the simulated reduction get the wrong answer.  

TODO
  - For complex functions use conjugates to test correctness of complex math
      Make c = a*b 
      set a[i] = (1 + 1i) and b[i] = (1 - 1i) 
      then each c[i] should be (2 + 0i) and the sum reduction 
      of vector c should be (ARRAY_SIZE*2 + 0i). 


